# vmec-jax

Laptop-friendly, end-to-end differentiable (JAX) rewrite of **VMEC2000** (fixed-boundary first).

`vmec-jax` aims to:
- reproduce VMEC2000 equilibria for the same inputs (output parity via `wout_*.nc` regressions),
- expose a clean, composable Python/JAX API (grad/JIT/vmap-ready),
- make sensitivity analysis and optimization workflows first-class (autodiff + implicit differentiation),
- remain hackable and readable as a research codebase.

For quick scripts, see the high-level driver helpers in `vmec_jax.driver` and
`vmec_jax.plotting` (also summarized in `docs/quickstart.rst`).

## Simple parity target (shaped tokamak, axisymmetric)

If you just want one fixed-boundary case that should match VMEC outputs,
start with an axisymmetric tokamak case. The bundled `shaped_tokamak_pressure`
is a good first “non-trivial” target (shaped surfaces with pressure and iota profile).

```bash
python examples/validation/circular_tokamak_vmecpp_vs_vmecjax.py --input examples/data/input.shaped_tokamak_pressure --wout examples/data/wout_shaped_tokamak_pressure_reference.nc
# To run the current solver instead of the reference-state parity check:
python examples/validation/circular_tokamak_vmecpp_vs_vmecjax.py --input examples/data/input.shaped_tokamak_pressure --wout examples/data/wout_shaped_tokamak_pressure_reference.nc --solve --solver vmec_gn --max-iter 80 --gn-damping 1e-6 --gn-cg-tol 1e-10 --gn-cg-maxiter 200
```

This script compares `fsqr/fsqz/fsql` against the provided `--wout` reference
(and VMEC++ if available). It is the
current “tight” parity target while the 3D cases are still being tuned.

Overview plots for the bundled `shaped_tokamak_pressure` reference `wout` are generated by:

```bash
python examples/visualization/circular_tokamak_overview.py --case shaped_tokamak_pressure
```

![shaped tokamak overview](docs/_static/figures/shaped_tokamak_pressure_overview.png)

Parity figures (Step-10 pipeline, B magnitude parity, bsub parity) are documented in
`docs/validation.rst`.

Project status: validated geometry/field/energy kernels, a working fixed-boundary pipeline,
and an increasingly complete VMEC-style force/residual path. Constraint-force plumbing
(`tcon`/`alias`) is now wired into the parity kernels; **lambda residual parity**, VMEC-quality
fixed-boundary convergence, and **Nyquist `bsub*` parity for some 3D cases** are still in
progress (see `CODEX_RESUME.md`).

## Key capabilities

- VMEC-style INDATA parsing and boundary evaluation.
- Differentiable geometry kernel on `(s,theta,ζ)` grids: metrics + Jacobian.
- VMEC-style profiles (pressure / iota / current) and volume integrals.
- Contravariant/covariant magnetic field components and VMEC-normalized magnetic energy `wb`.
- VMEC-style DFT trig/weight tables (`fixaray`) and `tomnsps` transforms for parity work.
- VMEC-style real-space synthesis in `bcovar` (enable via `use_vmec_synthesis=True`).
- Constraint-force pipeline (`tcon` + `alias`) integrated into force kernels.
- Fixed-boundary solvers:
  - lambda-only solve,
  - full `(R,Z,λ)` energy minimization,
  - L-BFGS variant (no external optimizer dependency).
- Parity tooling vs VMEC2000 `wout_*.nc` (Nyquist fields, scalar integrals, diagnostics figures,
  plus residual decomposition and full-vs-reference field comparisons).
- Step-10 parity (baseline): VMEC-style `forces` + `tomnsps` + `getfsq` scalars
  match the bundled symmetric `wout` references tightly (see
  `examples/validation/vmec_forces_rz_kernel_report.py` and
  `tests/test_step10_residue_getfsq_parity.py`). Force norms (`vp/wb/wp`, `fnorm/fnormL`)
  are computed dynamically from bcovar fields (no reliance on `wout` scalars).
- Advanced: implicit differentiation demos (custom VJP) for solver-aware gradients.

## Current parity status (Step-10 scalar residuals)

`vmec-jax` includes a Step-10 parity regression that compares VMEC-style scalar residuals
(`fsqr`, `fsqz`, `fsql`) computed from the ported `bcovar → forces → tomnsps → getfsq`
pipeline against bundled VMEC2000 reference `wout_*.nc` outputs.

The current relative errors are tracked in `docs/validation.rst`. Snapshot from
`examples/validation/step10_getfsq_parity_cases.py` (relative error
`|f̂-f|/max(|f|,ε)`):

The `solve fsq (vmec_gn)` column is the final invariant residual sum
`fsqr+fsqz+fsql` after running a fixed-boundary Gauss-Newton solve in vmec_jax.
Reproduce and print it via:

```bash
python examples/validation/step10_getfsq_parity_cases.py --solve-metric
```

| Case | fsqr | fsqz | fsql | solve fsq (vmec_gn) |
| --- | ---: | ---: | ---: | ---: |
| circular_tokamak | 5.1e-5 | 6.7e-5 | 2.8e-7 | (run script) |
| li383_low_res | 1.3e-3 | 4.4e-3 | 1.4e-5 | (run script) |
| circular_tokamak_aspect_100 | 8.4e-7 | 6.6e-7 | 2.3e-7 | (run script) |
| purely_toroidal_field | 1.3e-4 | 2.6e-4 | 1.9e-7 | (run script) |
| ITERModel | 3.5e-5 | 1.7e-5 | 2.5e-6 | (run script) |
| LandremanSengupta2019_section5.4_B2_A80 | 1.1e-6 | 2.5e-6 | 9.0e-9 | (run script) |
| n3are_R7.75B5.7_lowres | 6.4e-6 | 2.7e-5 | 9.1e-10 | (run script) |

Note: `lasym=True` (non-stellarator-symmetric) parity is deferred for now; the
bundled lasym cases are excluded from automated validation until the
`tomnspa` conventions are reconciled. See `docs/validation.rst` for the
latest status.

Not yet implemented (planned):
- Full VMEC-quality fixed-boundary convergence (VMEC-style preconditioners + force/residue parity).
- Free-boundary VMEC.
- MPI/parallelization.

## External baselines (VMEC2000 + VMEC++)

Two external baselines are supported for cross-checks when installed locally:

- **VMEC2000 (Fortran)** via its Python extension (`vmec`) and MPI driver.
- **VMEC++** via the `vmecpp` Python API.

Use the helper script:

```bash
# VMEC2000 (requires vmec python extension + mpi4py + netCDF4 + system libnetcdf)
python examples/validation/external_vmec_driver_compare.py --backend vmec2000 --case circular_tokamak

# VMEC++ (requires vmecpp + netCDF4)
python examples/validation/external_vmec_driver_compare.py --backend vmecpp --case circular_tokamak
```

The script runs the external code, writes a `wout_*.nc`, compares key fields to
the bundled references, and can optionally compute vmec_jax B-field parity
metrics. See `docs/validation.rst` for details and troubleshooting notes.

## Parity matrix (high level)

Status key: `OK` (covered by tests), `Partial` (matches in some cases / loose tolerances), `Planned`.
Scope note: parity tracking below is for **stellarator-symmetric / up-down symmetric** configurations
(`lasym=False`). Asymmetric equilibria (`lasym=True`) are planned but not implemented yet.

| Area | Axisym (ntor=0) | 3D (lasym=F) | Notes |
| --- | --- | --- | --- |
| INDATA parsing + boundary | OK | OK | `tests/` + `examples/tutorial/00_*` |
| Geometry (metrics + sqrtg) | OK | OK | Nyquist `gmnc/gmns` parity tests |
| B field (`bsup*`, `bsub*`, abs(B)) | OK | Partial | `bsup*` and `|B|` parity are tight; `bsub*` shows ~1-8% RMS gaps for some nfp>1 cases |
| Energy scalars (`wb`, `wp`, volume) | OK | OK | `tests/test_step10_energy_integrals_parity.py` + `wout.vp` checks |
| `wout` I/O (read + minimal write) | OK | OK | `tests/test_step10_wout_roundtrip.py` |
| Constraint pipeline (`tcon/alias/gcon`) | Partial | Partial | parity kernels + diagnostics wired |
| Step-10 `forces → tomnsps → getfsq` | OK | OK | scalar parity on bundled symmetric cases; includes VMEC `scalxc` post-tomnsps scaling |
| Fixed-boundary solvers | Partial | Partial | monotone energy decrease; not VMEC-quality yet |
| Implicit differentiation | OK | OK | example coverage; solver parity still WIP |
| Free-boundary VMEC | Planned | Planned | not implemented |
| Up-down / stellarator asymmetry (`lasym=True`) | Planned | Planned | deferred |
| Parallelization (multi-device) | Planned | Planned | not implemented |

## Next steps toward full VMEC2000 parity

Concrete milestones (correctness-first):

- Lock down VMEC numerics from the up-to-date sources (STELLOPT/VMEC2000 + VMEC++):
  - keep VMEC-style **DFT with precomputed trig/weight tables** as the canonical transform for parity,
  - verify mode ordering, `mscale/nscale`, and half/full mesh conventions used by `tomnsps`/`alias`.
- Expand Step-10 scalar parity coverage (more symmetric cases; tighter tolerances):
  - the current parity kernel matches VMEC’s `residue/getfsq` conventions, including the `scalxc` force scaling applied after `tomnsps` in `funct3d.f`,
  - add more bundled `input.*`/`wout_*.nc` pairs (from simsopt test files) and keep `tests/test_step10_residue_getfsq_parity.py` tight,
  - keep using the decomposition scripts (`examples/validation/residual_decomposition_report.py`, `.../residual_compare_fields_report.py`) to attribute any new-case gaps to specific blocks/modes.
- Close the remaining B-field parity gap for 3D (stellarator-symmetric) cases:
  - `bsup*` matches tightly on the VMEC internal grid, but `bsub*` differs by O(1-8%) in some nfp>1 cases (e.g. `li383_low_res`, `n3are`),
  - the likely root cause is a mismatch in VMEC’s *real-space synthesis/metric* conventions vs the current basis evaluation (parity + half-mesh rules),
  - plan: validate half-mesh metric conventions using the breakdown script
    (`examples/validation/bsub_parity_breakdown.py`) and reconcile the remaining
    parity mismatch in the `bcovar` metric construction.
- Finish the remaining VMEC2000 “plumbing” that affects Step-10 scalars:
  - reconcile any `bcovar` half/full mesh details that influence `forces` (beyond the dynamic norms path),
  - confirm axis rules (`jmin1/jmin2/jlam`) and `LCONM1` constraint behavior match `residue.f90` in the converged regime.
- Complete lambda residual parity:
  - finish the VMEC hybrid lambda force path,
  - tighten `fl*` block parity on symmetric cases (lasym deferred).
- Move from “parity kernels” to a VMEC-quality fixed-boundary solver:
  - port the 1D (and later 2D) preconditioners and use them in a Newton / quasi-Newton / preconditioned descent loop that converges comparably to VMEC2000 on the bundled cases,
  - ensure solver stopping criteria and reported diagnostics match VMEC (including how `fsq*` are computed during the iteration history).

## Findings + workplan snapshot

Current state:
- Step-10 scalar residual parity is tight on all bundled symmetric cases.
- `bsup*` parity is tight on the VMEC internal grid, and `|B|` parity is tight.
- The remaining **known gap** is `bsub*` parity for some 3D symmetric cases with `nfp>1`
  (e.g. `li383_low_res`, `n3are`), where RMS differences are O(1-8%).

Likely root cause:
- Our real-space synthesis for R/Z/L and the resulting half-mesh metric does not yet
  reproduce VMEC’s *internal* `totzsp` conventions (reduced theta grid, endpoint weights,
  `mscale/nscale`, and parity rules). This affects `guu/guv/gvv`, which directly feed `bsub*`.

Workplan (immediate):
1. Implement VMEC-style `totzsp` synthesis (using `fixaray` trig/weight tables) for R/Z/L
   and their derivatives on the VMEC internal grid.
2. Rebuild the half-mesh metric from those fields, then re-evaluate `bsub*` parity.
3. Tighten `tests/test_step10_bsub_parity.py` tolerances and update parity figures.

## Performance roadmap (JAX-first)

The current code is intentionally explicit and validation-driven. For performance, the biggest wins will come from swapping dense mode-sums for FFT-based spectral transforms and carefully structuring JAX compilation:

- Replace “basis-matrix” Fourier evaluation/projection only **after parity**:
  - VMEC++ uses DFTs with precomputed tables because of grid/weight conventions; FFTs are a later optimization and must reproduce the same scaling (`mscale/nscale`, endpoint weights, `ntheta1/2/3`) exactly.
  - candidate path: factorized DFTs (theta/phi separable) first, then FFT with explicit normalization.
- Fuse and batch the radial work:
  - use `jax.lax.scan` over `s` for recurrences and half-mesh operations to reduce memory pressure and compile time,
  - keep array layouts stable (`(ns, ntheta, nzeta)` contiguous) and avoid Python-side loops inside hot paths.
- Make compilation predictable:
  - enforce static shapes for `(ns, ntheta, nzeta, mpol, ntor)` in the core kernels,
  - use `jax.jit` with `static_argnames` (and small dataclass “static” bundles) to avoid recompiles.
- Solver-level algorithms that map well to JAX:
  - preconditioned nonlinear least-squares (Gauss-Newton / Levenberg-Marquardt) with matrix-free JVP/VJP and iterative linear solves (CG) for inner steps,
  - quasi-Newton (L-BFGS) as a fallback; optionally wire `jaxopt`/`optax` for robust line-searches and schedules while keeping end-to-end differentiability.
- GPU/TPU readiness:
  - avoid host callbacks in hot loops; keep diagnostics optional/off by default,
  - favor XLA-friendly primitives (`lax` control flow, `vmap`, FFTs) and keep `float64` supported (VMEC parity needs it; GPU `x64` can be slower but remains valuable for validation).

## Installation

Create an environment with Python ≥ 3.10.

Regular users (non-editable install):

```bash
git clone https://github.com/uwplasma/vmec_jax.git
cd vmec_jax
python -m pip install -U pip
python -m pip install .
```

Developers (editable install):

```bash
python -m pip install -e .
```

Recommended extras:

```bash
# JAX runtime (CPU)
python -m pip install ".[jax]"

# Read VMEC2000 `wout_*.nc` reference files
python -m pip install ".[netcdf]"

# Publication-ready figures in examples
python -m pip install ".[plots]"

# Build docs locally
python -m pip install ".[docs]"

# Dev tools
python -m pip install -e ".[dev]"
```

VMEC is typically run in float64. Enable x64 for JAX:

```bash
export JAX_ENABLE_X64=1
```

## Quickstart

Run a small validated workflow (inputs + reference `wout` files are bundled under `examples/data/`):

```bash
python examples/tutorial/00_parse_and_boundary.py examples/data/input.li383_low_res --out boundary.npz --verbose
python examples/tutorial/02_init_guess_and_coords.py examples/data/input.li383_low_res --out coords_step1.npz --verbose
python examples/tutorial/04_geom_metrics.py examples/data/input.li383_low_res --out geom_step2.npz --verbose
python examples/tutorial/05_profiles_and_volume.py examples/data/input.li383_low_res --out profiles_step3.npz --verbose
python examples/tutorial/06_field_and_energy.py examples/data/input.li383_low_res --wout examples/data/wout_li383_low_res_reference.nc --verbose
```

Compatibility wrappers live under `examples/compat/` and forward to `examples/tutorial/`.

## Examples

Examples are organized into:
- `examples/tutorial/`: step-by-step scripts (00-09).
- `examples/validation/`: parity checks vs bundled `wout_*.nc` + reports.
- `examples/visualization/`: plotting + VTK export.
- `examples/gradients/`: autodiff + implicit differentiation demos.
- `examples/solvers/`: solver experiments / convergence scripts.
- `examples/data/`: bundled regression inputs + reference `wout` files.

ParaView export (VTK surface fields + field lines):

```bash
python examples/visualization/vtk_field_and_fieldlines.py examples/data/input.li383_low_res --hi-res --outdir vtk_out
```

## Documentation

Sphinx docs live in `docs/`.

Build locally:

```bash
python -m sphinx -b html docs docs/_build/html
```

## Testing

```bash
pytest -q
```

If `netCDF4` is not installed, tests requiring `wout_*.nc` I/O are skipped.

## Contributing

Contributions are welcome. Practical ways to help:
- add parity regressions vs VMEC2000 (new cases, tighter tolerances),
- improve kernels (correctness-first; then JIT/vmap performance),
- expand documentation (derivations, conventions, and references),
- add examples that demonstrate differentiability and optimization workflows.

See `docs/contributing.rst` for style and workflow.

## License

MIT. See `LICENSE`.

## References / background

See `docs/references.rst` and the original VMEC literature for algorithmic context.

## Roadmap / step log

The detailed step-by-step porting log and current parity status live in `CODEX_RESUME.md` and `PORTING_NOTES.md`.
